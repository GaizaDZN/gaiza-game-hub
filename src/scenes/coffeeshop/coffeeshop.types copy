// Coffee shop game

import { Vector3 } from "three";
import { RandRange } from "../../helpers/helpers";

// General game state
enum GameState {
  init = "init", // start menu/login screen whatever
  loading = "loading", // for transitions
  opening = "opening", // cafe is not open. Can view and buy stock, set prices.
  sales = "sales", // main game: make coffee for x customers. Money goes up, stock goes down.
  closing = "closing", // see today's profit, and other stats
  dayEnd = "dayEnd", // give player option to start the next day (round).
}

// state while in sales state
enum SalesState {
  ordering = "ordering", // customer is ordering drinks
  mixing = "mixing", // player is mixing drinks
  saleOver = "saleOver", // order is complete or failed - if more customers in queue, return to ordering state
  end = "end", // no customers in queue - proceed to closing game state
}

export class Game {
  private gameState: GameState;
  private money: number;
  private reputation: number;
  private customers: Customer[];
  private currentCustomer: number; // index in customers
  private ingredients: Map<ResourceName, Resource>;
  private orderSuccess: boolean;
  private storeOpen: boolean;
  private activeBars: Map<ResourceName, number>;
  private version: number;

  public constructor() {
    this.gameState = GameState.init;
    this.money = 100;
    this.reputation = 100;
    this.customers = [];
    this.currentCustomer = 0;
    this.orderSuccess = false;
    this.storeOpen = false;
    this.ingredients = this.initIngredients();
    this.activeBars = new Map<ResourceName, number>();
    this.version = 0;
  }

  public reset(): void {
    this.gameState = GameState.init;
    this.money = 100;
    this.reputation = 100;
    this.customers = [];
    this.currentCustomer = 0;
    this.orderSuccess = false;
    this.storeOpen = false;
    this.ingredients = this.initIngredients();
  }

  getVersion() {
    return this.version;
  }

  private initIngredients(): Map<ResourceName, Resource> {
    const newIngredients = new Map<ResourceName, Resource>();

    newIngredients.set(
      ResourceName.Beans,
      new Resource(ResourceName.Beans, 20, 1)
    );
    newIngredients.set(
      ResourceName.Milk,
      new Resource(ResourceName.Milk, 20, 1)
    );
    newIngredients.set(
      ResourceName.Water,
      new Resource(ResourceName.Water, 20, 1)
    );
    newIngredients.set(
      ResourceName.Sugar,
      new Resource(ResourceName.Sugar, 20, 1)
    );
    return newIngredients;
  }

  getIngredients(): Map<ResourceName, Resource> {
    return this.ingredients;
  }

  setIngredients(ingredients: Map<ResourceName, Resource>) {
    this.ingredients = ingredients;
  }

  getState(): GameState {
    return this.gameState;
  }

  setState(state: GameState): void {
    if (this.gameState === state) {
      return;
    }
    this.gameState = state;
  }

  getMoney(): number {
    return this.money;
  }

  addMoney(money: number): void {
    this.money += money;
  }

  setMoney(money: number): void {
    this.money = money;
  }

  // opening state - player can open the store menu and purchase resources with money
  start(): void {
    this.setState(GameState.opening);
  }

  toggleStore(): void {
    this.storeOpen = !this.storeOpen;
  }

  purchaseItem(item: Resource, amount: number): void {
    this.ingredients.get(item.getName())?.increment(amount);
  }

  getActiveBars(resource: ResourceName): number {
    return this.activeBars.get(resource) || 0;
  }

  incrementActiveBar(resource: ResourceName, amount?: number): void {
    let currBars = this.activeBars.get(resource);
    if (currBars == undefined) {
      this.activeBars.set(resource, 0);
      currBars = this.activeBars.get(resource);
    }

    if (currBars != undefined) {
      if (amount == undefined) {
        this.activeBars.set(resource, currBars + 1);
      } else {
        this.activeBars.set(resource, currBars + amount);
      }
    }
  }

  decrementActiveBar(resource: ResourceName, amount?: number): void {
    let currBars = this.activeBars.get(resource);
    if (currBars == undefined) {
      this.activeBars.set(resource, 0);
      currBars = this.activeBars.get(resource);
    }

    if (currBars != undefined) {
      if (amount == undefined) {
        this.activeBars.set(resource, currBars - 1);
      } else {
        this.activeBars.set(resource, currBars - amount);
      }
    }
  }

  // Sales mode - loop through current customers. For each customer, receive
  // an order. Player must complete the order without errors to complete the sale.
  // Increase game money by sale price. Reduce stock of resources used.
  startSales(): void {
    if (this.gameState === GameState.sales) {
      return;
    }
    if (this.gameState != GameState.opening) {
      throw new Error("Can only enter 'sales' state from 'opening' state.");
    }
    this.setState(GameState.sales);
  }

  getCustomer(): Customer {
    return this.customers[this.currentCustomer];
  }

  nextCustomer(): void {
    // no customers
    if (this.customers.length === 0) {
      return;
    }
    // end of customers
    const lastCustomerIdx = this.customers.length - 1;
    if (this.currentCustomer === lastCustomerIdx) {
      return;
    } else {
      this.currentCustomer += 1;
    }
  }

  completeSale(): void {
    if (this.orderSuccess) {
      this.money += this.getCustomer().getOrder().getTotalPrice();
    } else {
      this.reputation -= this.getCustomer().getRepValue();
    }

    this.nextCustomer();
  }
}

// Order contains all order information for a customer
export class Order {
  private totalPrice: number;
  private drinks: Map<string, Coffee>;
  private textContent: string;

  public constructor() {
    this.totalPrice = this.setTotalPrice();
    this.drinks = new Map<string, Coffee>();
    this.textContent = this.generateTextContent();
  }

  getTotalPrice(): number {
    return this.totalPrice;
  }

  setTotalPrice(): number {
    let sum = 0;
    this.drinks.forEach((coffee) => {
      if (coffee.getQuantity() > 0) {
        sum += coffee.getPrice() * coffee.getQuantity();
      }
    });
    return sum;
  }

  // creates text content based on drinks
  generateTextContent(): string {
    if (this.drinks.size === 0) {
      return "I don't want any drinks...";
    }

    let content = "Give me ";
    const totalDrinks = this.drinks.size;

    let index = 0;
    this.drinks.forEach((drink) => {
      const quantity = drink.getQuantity();
      const drinkName = drink.getName();
      content += `${quantity} ${drinkName}${quantity > 1 ? "s" : ""}`;

      if (index < totalDrinks - 1) {
        content += ", ";
      }
      index++;
    });
    content += ".";
    return content;
  }

  getDrinks(): Map<string, Coffee> {
    return this.drinks;
  }

  addDrink(coffee: Coffee) {
    if (this.drinks.has(coffee.getType())) {
      this.drinks.get(coffee.getType())?.increment();
    }
  }

  getText(): string {
    return this.textContent;
  }

  setText(text: string): void {
    this.textContent = text;
  }
}

// RESOURCE /////////////////////////////////////////////////
export enum ResourceName {
  // INGREDIENTS
  Beans = "Beans",
  Water = "Water",
  Milk = "Milk",
  Sugar = "Sugar",
  // COFFEE
  Latte = "Latte",
  Espresso = "Espresso",
  Cappuccino = "Cappuccino",
  Americano = "Americano",
  Black = "Black",
}

export class Resource {
  protected name: ResourceName;
  protected quantity: number;
  protected price: number;

  public constructor(name: ResourceName, quantity: number, price: number) {
    this.name = name;
    this.quantity = quantity;
    this.price = price;
  }

  getName(): ResourceName {
    return this.name;
  }
  getQuantity(): number {
    return this.quantity;
  }

  increment(amount: number = 0) {
    if (amount < 0) {
      throw new Error("amount cannot be less than 0");
    }
    if (amount == 0) {
      this.quantity++;
    } else {
      this.quantity += amount;
    }
  }
  decrement(amount: number = 0) {
    if (amount < 0) {
      throw new Error("amount cannot be less than 0");
    }
    if (amount == 0) {
      this.quantity--;
    } else {
      this.quantity -= amount;
    }
  }
}

// COFFEE /////////////////////////////////////////////////
enum CoffeeType {
  Latte,
  Espresso,
  Cappuccino,
  Americano,
  Black,
}

const coffeeRecipes = new Map<number, CoffeeIngredients>();

coffeeRecipes.set(CoffeeType.Latte, { beans: 1, water: 1, milk: 1, sugar: 0 });
coffeeRecipes.set(CoffeeType.Espresso, {
  beans: 1,
  water: 1,
  milk: 0,
  sugar: 0,
});
coffeeRecipes.set(CoffeeType.Cappuccino, {
  beans: 1,
  water: 1,
  milk: 1,
  sugar: 0,
});
coffeeRecipes.set(CoffeeType.Americano, {
  beans: 1,
  water: 2,
  milk: 0,
  sugar: 0,
});
coffeeRecipes.set(CoffeeType.Black, {
  beans: 1,
  water: 1,
  milk: 0,
  sugar: 0,
});

const costPerUnit = {
  beans: 0.5,
  water: 0.1,
  milk: 0.3,
  sugar: 0.05,
};

enum CupSize {
  Small,
  Medium,
  Large,
  ExtraLarge,
}

interface CoffeeIngredients {
  beans: number;
  water: number;
  milk: number;
  sugar: number;
}

class Coffee extends Resource {
  coffeeType: number;
  size: number;
  ingredientsCost: number;
  private ingredients: CoffeeIngredients;
  markupPrice: number;

  public constructor(
    name: ResourceName,
    quantity: number,
    price: number,
    size: number,
    coffeeType: number
  ) {
    super(name, quantity, price);
    this.coffeeType = coffeeType;
    this.size = size;
    this.ingredients = this.setCoffeeIngredients(); // get ingredients from preexisting object (probably a JSON in the future)
    this.ingredientsCost = this.calculateIngredientsCost();
    this.markupPrice = 1.5;
  }

  getType(): string {
    switch (this.coffeeType) {
      case CoffeeType.Latte:
        return "Latte";
      case CoffeeType.Cappuccino:
        return "Cappuccino";
      case CoffeeType.Americano:
        return "Americano";
      case CoffeeType.Espresso:
        return "Espresso";
      case CoffeeType.Black:
        return "Black";
      default:
        throw new Error(`coffee type ${this.coffeeType} not recognized!`);
    }
  }

  getSize(): string {
    switch (this.size) {
      case CupSize.Small:
        return "Small";
      case CupSize.Medium:
        return "Medium";
      case CupSize.Large:
        return "Large";
      case CupSize.ExtraLarge:
        return "XL";
      default:
        throw new Error(`coffee type ${this.coffeeType} not recognized!`);
    }
  }

  // calculateIngredientsCost adds up the cost of the ingredients used to break even.
  calculateIngredientsCost(): number {
    const { beans, water, milk, sugar } = this.ingredients;
    return (
      beans * costPerUnit.beans +
      water * costPerUnit.water +
      milk * costPerUnit.milk +
      sugar * costPerUnit.sugar
    );
  }

  // returns the price of
  getPrice(): number {
    return this.ingredientsCost * this.markupPrice;
  }

  setMarkup(markup: number): void {
    if (markup < 1) {
      // trigger some warning about selling at a loss - Default: 1.5 (50% is "Keystone Markup")
    }
    this.markupPrice = markup;
  }

  setPrice(price: number) {
    this.price = price;
  }

  // setCoffeeIngredients sets the ingredients depending on the coffee type
  setCoffeeIngredients() {
    const ingredients = coffeeRecipes.get(this.coffeeType);
    if (ingredients != undefined) {
      return ingredients;
    } else {
      throw new Error("Invalid coffee type");
    }
  }
}

// BARISTA /////////////////////////////////////////////////
export const stepSize = 0.6;
export const personSize = 0.4;

// class Barista {
//   name: string;
//   speed: number;
//   position: Vector3;

//   public constructor(name: string, speed: number, position: Vector3) {
//     this.name = name;
//     this.speed = speed;
//     this.position = position;
//   }

//   getName(): string {
//     return this.name;
//   }

//   getSpeed(): number {
//     return this.speed;
//   }

//   getPosition(): Vector3 {
//     return this.position;
//   }

//   setPosition(position: Vector3) {
//     this.position = position;
//   }

//   move(direction: string) {
//     switch (direction) {
//       case "up":
//         break;

//       default:
//         break;
//     }
//   }
// }

export enum MoveKey {
  Up = "w",
  UpArrow = "ArrowUp",
  Down = "s",
  DownArrow = "ArrowDown",
  Left = "a",
  LeftArrow = "ArrowLeft",
  Right = "d",
  RightArrow = "ArrowRight",
}

export class Player {
  position: Vector3;
  public constructor(position: Vector3) {
    this.position = position;
  }

  move(key: string) {
    switch (key) {
      case MoveKey.Up:
      case MoveKey.UpArrow:
        this.position.y += stepSize;
        break;
      case MoveKey.Down:
      case MoveKey.DownArrow:
        this.position.y -= stepSize;
        break;
      case MoveKey.Left:
      case MoveKey.LeftArrow:
        this.position.x -= stepSize;
        break;
      case MoveKey.Right:
      case MoveKey.RightArrow:
        this.position.x += stepSize;
        break;
      default:
        break;
    }
  }
}

// CUSTOMER /////////////////////////////////////////////////

enum CustomerType {
  Patient,
  Normal,
  Impatient,
}

class Customer {
  private customerType: CustomerType;
  private patience: number;
  private repValue: number;
  private order: Order;

  public constructor(customerType: CustomerType) {
    this.customerType = customerType;
    this.order = this.generateOrder();
    this.patience = this.setPatience();
    this.repValue = this.setRepValue();
  }

  // creates a random coffee - add some additional rules
  // based on customer type eventually
  private generateCoffee(): Coffee {
    const totalCoffees = Object.keys(CoffeeType).length;
    const totalSizes = Object.keys(CupSize).length;
    const randCoffee = RandRange(0, totalCoffees);
    const randSize = RandRange(0, totalSizes);
    // const randAmount = RandRange(1, 2)

    const coffeeName = this.setCoffeeName(randCoffee);

    return new Coffee(coffeeName, 1, 1, randSize, randCoffee);
  }

  setCoffeeName(num: number): ResourceName {
    switch (num) {
      case 0:
        return ResourceName.Latte;
      case 1:
        return ResourceName.Espresso;
      case 2:
        return ResourceName.Cappuccino;
      case 3:
        return ResourceName.Americano;
      case 4:
        return ResourceName.Black;
      default:
        return ResourceName.Latte;
    }
  }
  // add a coffee to the customer's order
  addCoffee(coffee: Coffee): void {
    this.order.getDrinks().get(coffee.getType())?.increment();
  }

  getPatience(): number {
    return this.patience;
  }

  setPatience(): number {
    switch (this.customerType) {
      case CustomerType.Patient:
        return 30;
      case CustomerType.Normal:
        return 20;
      case CustomerType.Impatient:
        return 10;
    }
  }

  getRepValue(): number {
    return this.repValue;
  }

  setRepValue(): number {
    switch (this.customerType) {
      case CustomerType.Patient:
        return RandRange(0.5, 1);
      case CustomerType.Normal:
        return RandRange(0.5, 1.5);
      case CustomerType.Impatient:
        return RandRange(0.75, 2);
    }
  }

  getOrder(): Order {
    return this.order;
  }

  generateOrder(): Order {
    const newOrder = new Order();
    const orderNum = Math.floor(RandRange(1, 4));

    for (let i = 0; i < orderNum; i++) {
      const newCoffee = this.generateCoffee();
      newOrder.addDrink(newCoffee);
    }

    return newOrder;
  }
}

// MACHINE /////////////////////////////////////////////////
export enum MachineTypes {
  Espresso,
  Grinder,
  Brewer,
  Steamer,
}

enum MachineEventType {
  WorkStarted = "workStarted",
  WorkFinished = "workFinished",
}

type MachineEventListener = (event: MachineEvent) => void;

interface MachineEvent {
  type: MachineEventType;
  machine: Machine;
  timestamp: number;
}

interface IngredientQuantities {
  [ingredient: string]: number;
}

class Machine {
  machineType: number;
  workTime: number;
  ingredients: IngredientQuantities;
  required: IngredientQuantities;
  active: boolean;
  timeStarted: number;
  private listeners: MachineEventListener[] = [];

  public constructor(
    machineType: number,
    workTime: number,
    ingredients: IngredientQuantities,
    required: IngredientQuantities
  ) {
    this.machineType = machineType;
    this.workTime = workTime;
    this.ingredients = ingredients;
    this.required = required;
    this.active = false;
    this.timeStarted = 0;
  }

  addListener(listener: MachineEventListener): void {
    this.listeners.push(listener);
  }
  removeListener(listener: MachineEventListener): void {
    this.listeners = this.listeners.filter((l) => l !== listener);
  }

  private triggerEvent(event: MachineEvent): void {
    this.listeners.forEach((listener) => listener(event));
  }

  getType(): number {
    return this.machineType;
  }
  getWorkTime(): number {
    return this.workTime;
  }

  hasIngredients(): boolean {
    for (const requiredIngredient in this.required) {
      if (
        Object.prototype.hasOwnProperty.call(this.required, requiredIngredient)
      ) {
        if (
          !Object.prototype.hasOwnProperty.call(
            this.ingredients,
            requiredIngredient
          ) ||
          this.ingredients[requiredIngredient] <
            this.required[requiredIngredient]
        ) {
          return false; // Return immediately if a requirement isn't met
        }
      }
    }
    return true;
  }

  noIngredients() {
    // trigger a UI message about not having enough ingredients
    console.log("not enough ingredients!");
  }

  startWork(): void {
    if (this.hasIngredients()) {
      this.active = true;
      this.timeStarted = new Date().getTime();
      this.triggerEvent({
        type: MachineEventType.WorkStarted,
        machine: this,
        timestamp: this.timeStarted,
      });
    } else {
      this.noIngredients();
    }
  }

  finishWork(): void {
    const timeNow = Date.now();
    const timeSince = timeNow - this.timeStarted;
    if (timeSince >= this.workTime) {
      this.active = false;
      this.triggerEvent({
        type: MachineEventType.WorkFinished,
        machine: this,
        timestamp: timeNow,
      });
    }
  }
}
